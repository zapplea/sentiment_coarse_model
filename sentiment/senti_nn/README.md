#1. input batch size:
there is no limitation to the size of batch. You can change code in sentinn_train.

#2. Metrics
You can write a new metrics program. 
In the classifier, the final output is prediction result with shape (batch size, attributes number+1, 3).

#3. Data:
###3.1 sentiment labels:
shape = (batch size, attributes number+1, 3). The non-attribute should be considered and its the last attribute. 
batch= [sentiment for sentence1, ...]
sentiment for sentence1 = [sentiment for attribute1, ..., sentiment for non-attribute]
sentiment for attribute1 = [0,0,1]
The first represent neutral, the second represents negative, the third is positive. When a sentiment is true, then the corresponding position will be 1.
If an attribute(including non-attribute) doesn't appear in a sentence, then its sentiment is neutral. 

###3.2 attributes labels:
The same to the attribute function, and the shape is (batch size, attributes number). 
I will add one position in the end of each vector to represent non-attribute by the program, and the shape will be (batch size, attributes number +1). 
This prograss is finished by the program so don't worry.

###3.3 sentences:
The same to the attribute function in current state, but in the future, we would use the version without punctuation because of dependency parsing.

###3.4 wordembedding table
The same to attribute function

###3.5 dependency path
Need to input dependency path of each sentence. These two things will be generated by util/dependency_parser/dependency_generator.py

#4. Wordembedding:
In the dependency parsing version, the relationship words in sentiment path should be involved. Need to check how many words is unk in the generated sentence.

#5. path dependency version
### relation words
dependency relathion words: since these words are special and cannot be find in the original word embedding, we extract all of them and form a vocabulary of 
relation words. The relation words are something like "#case#", or "#amod#". They will be randomly initialized, which means we use np.random.normal to give each 
word a embedding. Then this vocabulary will be attached at the end of the original word embeddings, so we can use one lookup table to process sentences and 
dependency path.
In the program, just need to know the number of relation words.

#6. paramters:
###6.1 new paramters:
'rel_words_num': the number of relation words.
'rel_word_dim': dimension of relation words' embedding. should be the same to original word embeddings' dimension.

#7. generate dependency path
Use util/dependency_parser/dependency_generator.py to generate sentences (without punctuation) and dependency path.
It will generate two json file: train.json and test.json. 
In each file, it contains two elements: 'encoded_tables' and 'encoded_sentences'. 
The e'ncoded_sentences' contain all sentences in test/train dataset. Words are converted to the number in the  wordembedding.
In the 'encoded_tables', it contains each sentence's dependency path.




#Note:
The attribute is given even in the test. So, if the attributes cannot be recognized correctly, the performance of the sentiment will be influenced.
TODO:for coarse model, there should be something to eliminate the influence of padded sentences' labels.












